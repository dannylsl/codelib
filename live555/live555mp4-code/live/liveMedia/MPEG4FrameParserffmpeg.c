/*
 * Dirty implementation .
 * have to convert to a class later.
 * Supports only video frames.
 *
 * compiler options
 * gcc MPEG4FrameParserffmpeg.c -lavformat -lavcodec -lavutil -lswscale -lz
 * archan
 * */

/*
So there is a problem with the duration hence i have decided upon the following approach.
> while calling init i will get the first frame but will not return it to the caller.
> when the getNextFrame is called i will get the second frame get duration for the first and return first.
> at the last the file ends the avcodecRead will return NUll now i will sent the exrtra frame ...

 */


#include <libavcodec/avcodec.h>
#include <libavformat/avformat.h>
#include <libswscale/swscale.h>
#include <stdio.h>
#include <stdlib.h>

#include "VideoRTPSink.hh"

AVFormatContext *pFormatCtx;
int i, videoStream, flag = 0;
AVCodecContext* codecCtx;
AVCodec *pCodec;
AVFrame *pFrame, *pFrame1; // the pFrame1 stores the next frame used for
AVPacket ppacket;
int frameFinished,lastFrame = 0;
int numBytes;
uint8_t *buffer;
float duration;

void MPEG4FrameParser_init(const char* filename) {
    av_register_all();
    duration = 0;
    if ((av_open_input_file(&pFormatCtx, filename, NULL, 0, NULL) != 0)
            || (av_find_stream_info(pFormatCtx) < 0))
        return;
    // Find the first video stream
    videoStream = -1;
    for (i = 0; i < pFormatCtx->nb_streams; i++) {
        if (pFormatCtx->streams[i]->codec->codec_type == CODEC_TYPE_VIDEO) {
            videoStream = i;
            break;
        }
    }
    if (videoStream == -1)
        return; // Didn't find a video stream

    codecCtx = pFormatCtx->streams[videoStream]->codec;
    pCodec = avcodec_find_decoder(codecCtx->codec_id);
    if (pCodec == NULL)
        return; // Codec not found

    // Open codec
    if (avcodec_open(codecCtx, pCodec) < 0)
        return; // Could not open codec

    // Hack to correct wrong frame rates that seem to be generated by some codecs
    if (codecCtx->time_base.num > 1000 && codecCtx->time_base.den == 1)
        codecCtx->time_base.den = 1000;
    pFrame = avcodec_alloc_frame();
    pFrame1 = avcodec_alloc_frame();
    // get the first frame fr the duratin
    while (av_read_frame(pFormatCtx, &ppacket) >= 0) {
        // Is this a ppacket from the video stream?
        if (ppacket.stream_index == videoStream) {
            // Decode video frame
            avcodec_decode_video(codecCtx, pFrame, &frameFinished,
                    ppacket.data, ppacket.size);
            // Did we get a video frame?
            if (frameFinished)
                goto t;
        }
    }
t:
    duration = 1.0 * (ppacket.pts * 1000) * codecCtx->time_base.num / codecCtx->time_base.den;
    flag = 1;
}

void getNextMPEG4Frame(uint8_t ** buff,int MaxSize,int * TruncBytes,int *size, float * presentationTime, float* dur) {
    if (flag == 0) return NULL; // check whether the ffmpeg library is initialised or not
    if(lastFrame){
        goto LastFrame;
    }
    pFrame1 = pFrame;
    frameFinished = 0;
    while (av_read_frame(pFormatCtx, &ppacket) >= 0) {
        // Is this a ppacket from the video stream?
        if (ppacket.stream_index == videoStream) {
            // Decode video frame
            avcodec_decode_video(codecCtx, pFrame, &frameFinished,
                    ppacket.data, ppacket.size);
            // Did we get a video frame?
            if (frameFinished)
                goto t;
        }
    }
t:
    //initialise the size and presentation time for the frame.
if(!frameFinished){
    lastFrame = 1;
}
    *presentationTime = 1.0 * (ppacket.pts / 1000) * codecCtx->time_base.num / codecCtx->time_base.den;
LastFrame:
    * dur = *presentationTime - duration;
    duration = *presentationTime;   //might return segmentation fault.
    *size = ppacket.size;
    if(ppacket.size < MaxSize){
        memcpy(*buff,pFrame1,ppacket.size);
        *TruncBytes = 0;
    }else{
        memcpy(*buff,pFrame1,MaxSize);
        *TruncBytes = ppacket.size-MaxSize;
    }

}

/*
 * as of now implementing all this in mpeg4frame_init
void * getMPEG4videoStream() {
    if (flag == 0) MPEG4FrameParser_init(); // check whether the ffmpeg library is initialised or not
    if ((av_open_input_file(&pFormatCtx, filename, NULL, 0, NULL) != 0)
            || (av_find_stream_info(pFormatCtx) < 0))
        return NULL;
    // Find the first video stream
    videoStream = -1;
    for (i = 0; i < pFormatCtx->nb_streams; i++) {
        if (pFormatCtx->streams[i]->codec->codec_type == CODEC_TYPE_VIDEO) {
            videoStream = i;
            break;
        }
    }
    if (videoStream == -1)
        return -1; // Didn't find a video stream
    return pFormatCtx->streams[videoStream];

}
 */
